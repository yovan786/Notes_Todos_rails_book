sample_app
===========
By default rails uses TestUnit for testing, but we will use RSpec. We must suppress the creation of the default test directory.
rails new sample_app -T -d mysql
cd sample_app
We must install RSpec. In the Gemfile we must add the following lines:

group :test, :development do
  gem "rspec-rails", "~> 2.8"
end

bundle install
Before modifying our .gitignore file, we must generate some rspec related files:
rails generate rspec:install
Modify the .gitignore file as in the railstutorial.org/book
git init
git add.
git commit -m "Initial commit"
create a github repo for the project called sample_app
git remote add origin git@github.com:yovan-juggoo-ruby/sample_app.git
git push origin master
add yovan-juggoo as a collaborator
modify README using markdown language
git mv README README.markdown && git commit -am "Improved the README"
git push
heroku create 
git push heroku master

We want to create some static pages (home, contact, about, etc). We need a controller to manage our static pages:
We will generate the Pages controller with two actions: home and contact

rails generate controller Pages home contact 

This will modify our routes.rb  file, create the pages_controller.rb, create our views, create our pages_helper.rb and generate rspec files for the controller, views and helper class.
Open the routes.rb and we can see the two lines
get "pages/home"
get "pages/contact"
We can navigate to the home page: http:localhost:3000/pages/home and view the static content of the app/views/pages/home.html.erb view. Same goes for the contact page.

git status
git add .
git commit -m "Added a Pages controller"
We will use automated TDD - writing the test before writing the application code.
We will test for the presence of an about page
First we remove the tests for our views and helpers. We will do these tests in the controllers test.
git rm -r spec/views
git rm -r spec/helpers
ls spec -> spec_helper.rb (file used by rspec ro run) and the controllers/pages_controller_spec.rb
We can run the spec directory for all of our tests(here we have one only).
rspec spec/ -> We must wait for long but we are finally green
The overhead for running our tests is because of the loading of the RSpec environment in memory. Spork can be used to speed RSpec.
Run spork in a separate terminal
rspec spec/ in another terminal -> Tests are dramatically speed up.
Now instead of running rspec spec/, we will use autotest which gives us a desktop notification on the status of our tests - growl notification.
Note: We have 4 terminals:
 - the first to issue commands
 - second for autotest
 - third for spork
 - forth for running the server
We will write a failing test for our about page - it does not exist. First of all we will open up the pages_controller_spec.rb file. All here is pure ruby. Rspec exploits Ruby to make a domain specific language (DSL).

require 'spec_helper'
describe PagesController do
	... Other tests
	describe "GET about" do
		it "should be successful" do
			get 'about' -> First we make an http get for the about ACTION get :about
			response.should be_success -> Success should be our response code for our get
		end
	end
end

On saving the file, autotests fails. 
Sometimes we have to restart Spork. Stop autotest, start spork and start autotest.
We have to
1. Create a route for the about page in routes.rb
2. Create the about action in our Pages controller
3. Create the pages/about.html.erb
4. Finally test in the browser: http://localhost:3000/pages/about

Tests are important
1. To modify code and test if it did not break previous code
2. To refactor code, i.e change functionality of some code but not its definition.

We will create dynamic pages - Dynamic title for each page.

it "should have the right title" do
	get :home
	response.should have_selector("title", :content => "Ruby on Rails Sample App | home")
end

have_selector is used to test HTML tags. The test above will fail - title in views/layouts/application.html.erb is SampleApp.
For this to work we must add the webrat gem to our Gemfile as have_selector is a webrat method:
gem 'webrat'
bundle install

1. Edit the home.html.erb file by adding the doctype, head with the title, and the already existing code.
2. Autotest will still fail. We have removed the tests on our views and are trying to test the view in our pages_controller_spec.rb file. By default this test suite will not render the views. We have to use the method render_views in our controller spec before running any view related tests.
3. Our test should pass now
4. We do the same test for the other views
5. We will modify the views html so that it is more meaningful.
6. But as we can see we have the title still showing SampleApp in the browser.
7. rm views/layouts/application.html.erb 
8. We can see that the titles are right for the pages but there is duplication of HTML code. We will add dynamic content to our views also.
9. In the actions add an instance @title="Home" and embed the title in our home view <%= title%>. Do the same for the other views. Our tests should still work.
10. We restore the default application view, change its title and remove unnecessary HTML in our views. But in our browser we will get empty pages: Blank space.
11. We will test that our HTML has a non-blank body by using regular expressions - use rubular. We want to match empty or blank body -> <body></body> or <body>   <body>
=> /<body>\s*<\/body>/ => 0 or any number of white space
 
 it "should have a non-blank body" do
 	get :home
 	response.body.should_not =~ /<body>\s*<\/body>/   -> response.body is the whole rendered HTML
end

12. We still are red. We must add embedded ruby: <%= yield%>. Now we don't have errors.
13. Add the csrf_meta_tag for cross request site forgery.
14. 
git status
git add .
git commit -am "added a site layout"
it push
git push heroku master
heroku open to view in browser

If server down we have to run the 3 commmands each in a new terminal window.
rails s
spork
autotest
We want a global title that we will specialise. A possible way to do this is by using a helper.
Note: All helpers in the helpers folder are available in any view. 

module ApplicationHelper
	# Return a title on a per-page basis.
	def title
		base_title = "Ruby on Rails Tutorial Sample App"
		if @title.nil? #By default @title being an instance variable is nil
			base_title #methods return the last line evaluated
		else
			"#{base_title} | # {@title}"
		end
	end
end

1. Change the title in application.html.erb to <%= title%> and check in browser
2. git status 
git commit -am "Added a title helper"
3. We sill use blueprint framework to create a base for our styling.
copy the blueprint folder in the zipped file in the public/stylesheets folder
4. Add the following lines to the appication.html.erb file
<%= stylesheet_link_tag 'blueprint/screen', :media => 'screen' %>
<%= stylesheet_link_tag 'blueprint/print', :media => 'print' %>

stylesheet_link_tag is a rails funtion that takes a string and a hash as arguments.
stylesheet_link_tag('blueprint/screen', { :media => 'screen' })

The above is rendered as
<link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/blueprint/screen.css?1280830757"/>
The 1280830757 is there so that the page reloads the file if it changes (the number changes) - as normally browsers cache these files.

We will use the rails console to run some code.
rails c or rails console. The rails console is irb with access to rails components (controllers, helpers, database, etc).

1. "foo".concat("bar")
2. first_name = "Yovan" -> This returns the string literral "Yovan"
3. "#{first_name} #{last_name}" -> This is called interpolation
4. puts returns nil
5. print returns nil
6. "foobar".length
7. "foobar".empty?
8. "".empty? is true
9. "foobar".blank? not Ruby specific but rails specific. Useful in forms.
10. puts "Both strings are empty"  if x.empty? || y.empty?
11. if x.empty? || y.empty?
		puts "Both strings are empty"
	end
12. nil.empty? -> NoMethod error
13. nil.to_s.empty? -> true -> nil.to_s = ""
=> "#{nil}" => ""
14. false, true and nil are boolean values. "", 0 are not false but truthy values.
15. !!0, !![], !!"" returns true
16. ApplicationHelper is a module, hence gets included in the controller's class.
17. "foo bar    baz".split -> ["foo", bar, baz] is an array of strings splitted on a whitespace.
"fooxxxbarxxxbax".split("xxx")
18. a = [10, 20, 30, 40]
a[-1] = 40
a.last
a.second = 20 -> rails not ruby
a.length
a.empty?
a.sort
a.sort!
a.reverse
a.reverse!
a.shuffle
a.shuffle!
(1..52).to_a.shuffle
[1, 2] << 3 -> [1,2,3] #push operator
[1,2,"test"] << (1..5) -> [1,2,"test", 1..5]
arrays are Enumerable. Enumerable is a module in ruby where we can iterate on each element.
(1..5).each {|i| puts 2 ** 1} -> 2 4, 8, 16, 32 printed on the screen.

a = []
(1..5).each{ |i| a << 2 ** i}
a -> returns [2 4, 8, 16, 32]

It is better to use a map
a = [];
(1..5).map {|i| a << 2 ** i} -> returns [2 4, 8, 16, 32]

The same in one line: a = (1..5).map {|i| 2 ** i}
or (1..5).map do |i|
		2 ** i
	end

10.times do --> Here we don't need the i argument
	puts "Betulgeuse"
end

Where we see the keyword do, we are using a block. For example in our tests and in the Gemfile.
%w[foo bar baz] -> ["foo bar baz"]
%(a b c) -> "a b c"
b = %w[foo bar a b c].map {|string| string.upcase} -> ["FOO", "BAR", "A", "B", "C"]
%w[a b c].map(&:upcase) -> ["A", "B", "C"]

"foo".class -> String
:foo.class -> Symbol
user = {}
user.class -> Hash
Arrays are indexed by integers but hashes can use more generic data-type.
user["first_name"] = "Yovan"
user["last_name"] = "Juggoo"
user -> {"first_name" => "Yovan", "last_name" => "Juggoo"}
user["first_name"] -> "Yovan"
user[12] = "Hello"
user -> {"first_name" => "Yovan", "last_name" => "Juggoo", 17 => "Hello"}
Hashes don't have an order on rails 3 compared to arrays which have an order
Hashes are key value pairs. The order is not important. What is important is that for every key there is a corresponding value.
employee = { "role" => "manager", "department" => "Programming", "name" => "John Doe", "salary" => 98500 }
In Rails application and in general in Ruby we use symbols as keys, not strings.
Symbols are more efficient for comparision than strings. "test" == "Test". Here comparison is done one character at a time. Symbols comparison are done on one go.

flash = { :success => "It worked!", ":error" => "It failed"}
flash.each do |key, value|
	puts "Key: #{key.inspect}  \nValue #"{value.inspect}"
end

key.inspect is important cause key only will be interpolated as a string => key.to_s
puts [1, 2 ,3] prints all the elemets one by one
puts [1, 2, 3].inspect puts the array to the console
puts [1, 2, 3].inspect is same as p [1, 2, 3]

s = String.new("my_string")
a = Array.new([1, 2, 3])
h = Hash.new -> We don't initialise it. This returns {}
h[:name] = "Yovan Juggoo"
h -> {:name => "Yovan Juggoo"}
s.class.superclass -> Object
s.class.superclass.superclass -> BasicObject
s.class.superclass.superclass.superclass

class Word
	def palindrome? string
		string == string reverse
	end
end
w = Word.new
w.palindrome('foobar') -> false
w.palindrome('level') -> true

reset the console

class Word < String
	def palindrome?
		self == self.reverse
	end
end

w= Word.new('deified')
w.class -> Word
w.palindrome? -> true

We will add the palindrome? method directly on the String class

class String
	def palindrome?
		self == reverse
	end
end

"deified".palindrome?

We can load our pages controller in our console
pages = PagesController.new
pages.home -> "Home"

A ruby class - for testing purposes
class User
	attr_acessor :name, :email

	def initialize (attributes = {})
		@name = attributes[:name]
		@email = attributes[:email]
	end

	def formatted_email
		"#{@email} <#{@email}>"
	end
end

To use this code in our console, we must require it.
require './user'
user = User.new(:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com")
user.email #getter
user.email = "yovan.juggoo.ruby@gmail.com" #setter

Nested hash - hash having a hash as a key
params = {}
params[:user] = {:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com"}
params -> {:user => {:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com"}}
user = User.new(params[:user])

We will refactor our pages_controller_spec.rb file:
require 'spec_helper'
describe PagesController do
	render_views
	
	before(:each) do -> runs the same code before running each example (test bloc)
		@base_title  = "Ruby on Rails Tutorial Sample App" #@base_title should be an instance variable
	end

	describe "GET home" do
		it "should be successful" do
			get "home"
			response.should be_success
		end

		it "should have the right title" do
			get "home"
			response.should have_selector("title", :content => "#{@base_title} | Home")
		end

	end
	... Other tests
end

git status
git add .
git commit -m "Added helper and stylesheet"
git push
git push heroku
heroku open


Chapter 5 - Begin with ruby_0502.flv
--------------------------------------
As we will be making a large number of changes, we will create and work on a new branch of the master branch.
git checkout -b filling-in-layout

We will format our page as in mockup.png. The main page to be formatted is layouts/application.html.erb

- The HTML5 Shiv enables use of HTML5 sectioning elements in legacy Internet Explorer and provides basic HTML5 styling for Internet Explorer 6-9, Safari 4.x (and iPhone 3.x), and Firefox 3.x.
- We added also support for IE < 8 
- We added our custom stylesheet.
- blueprint expects that the content is placed in a container class.

image_tag (path, alt, class) is a helper method.
<%= image_tag("flower-logo.jpg", :alt => "Sample App", :class => "round")%>
is rendered to : <img alt="Sample App" class="round" src="/assets/logo.png" />

We have link_to methods for rendering our navigation.
Note here we are using '#' to stub the URL, but later we will use named routes.

The main content goes into a section tag.

We add our custom styles in custom.css to make the page more appealing.

Soon we can see that the application.html.erb file is becoming cluttered in the head of the HTML document. We will use a partial for stylesheets. In the layouts folder we will create an _stylesheets.html.erb partial.
We use the render helper method to include our partial.
<%= render 'layouts/stylesheets'> -> rails recognises partials by their name beginning with an underscore, but we use them in our layouts without the '_'.

We did same with the header and the footer. Note: for remote resources, we can either use hthe link_to helper method, or the classic <a href="http://path.to.resource.com">Resource</a>

For structuring purposes we stubbed our links. For example in the _footer.html.erb file, we have:
<li><%= link_to "About", "#" %></li>

We could use 
<li><%= link_to "About", "/pages/about" %></li> or <li><%= link_to "About", "/about" %></li> but this is not the rails way of doing things - use NAMED ROUTES.
The advantages:
- We can customize our /pages/about URL by using /about for example - routes.rb
- If we use the about link in several pages, we have to update the URL at one place only.
<li><%= link_to "About", about_path %></li>
But this breaks our page because there is no such path. We revert back to <li><%= link_to "About", "#" %></li>
 and will use integration testing to solve the pb.

rails g integration_test layout_links ->  create spec/requests/layout_links_spec.rb

Note in BDD we used get :home (named ROUTES), but in integration testing we use URLs ('/')
What do we want:
- The homepage to be /
- Contact page to be at /contact instead of /pages/contact
- Same for /about, /help

We use BDD to add a help page: pages_controller_spec.rb.

To match a named routes to a URL, for example match /contact with /pages/contact,
In the routes.rb file:
match '/contact', :to => 'pages#contact' -> match is a helper method. We are matching /contact and routing it yo the PagesController and the contact action. This creates a named route: contact_path
Same goes for /about, /help. 
/ is particular.  root :to => 'pages#home'
Note: You can have the root of your site routed with "root". Just remember to delete public/index.html.
We can now delete the get "pages/about", etc and use the match method.
In the header partial, we will link out logo to the home page. We will use a helper logo to get the image.

Note: Suppose we have some uncommited changes. We want to append these changes to our last commit.
git add .
git commit --amend -> This will open the git editor. We can close it. The uncommited changes have been amended to the last commit.
git log -p -> The changes that were made.

A sign up creates a new user -> A UserController having a new action to create a new user.
rails g controller Users new
rm -rf spec/helpers && rm -rf spec/views -> These don't form part of git, but we dont need them either.

BDD testing for the title for the new action: "Sign up".
We would like to be redirected at the /users/new page with /signup
As previously, we use integration testing to map and test our signup_path.

Note: Integration testing is mostly used to after the work has been done - to double check.
For example we can test our links.

git status
git add .
git commit -am "Added UsersController and layout link tests"
git checkout master
git merge filling-in-layout
git push origin master

ActiveRecord is the default Rails library to deal with DB. 
We will use migrations - interface to SQL DDL.
In scaffolding the controller, model and views are generated for us. But as we generated manually our controller, we will generate the data model.

git checkout -b modeling-users -> Create a new branch
rails g model User name email -> Controllers are plurial and models are singular

20160816132549_create_users.rb -> Generated class for us which inherits from Migration. We already have columns defined.
create_table :users do |t| -> t is the data model
We can see that rails defines our fields as columns and t.timestamps represent the created_at and updated_at columns. The id column is automatically created for us. We can see the sane in schema.rb.

rake db:migrate -> Creates our tables in the database
rake db:rollback -> Deletes the table

rake db:migrate

Add gem 'annotate' to group development so that we can annotate our models.
bundle install
annotate -> Annotated user: Annotated (2): app/models/user.rb, spec/models/user_spec.rb
Useful so that we can clearly see the columns and datatypes.

We would like to restrict the fields that are accessible via the web interface. For example id is not a public field.
Use attr_accessible :name. :email -> Already done for us.
