Http request	URL				Action 		Purpose
===================================================================
GET 			/users 			index 		page to list all users
GET 			/users/1 		show		page to show user with id 1
GET  			/users/new 		new			page to make a new user
POST  			/users 			create		create a new user
GET  			/users/1/edit 	edit		page to edit user 1
PUT  			/users/1 		update		update user with id 1
DELETE  		/users/1 		destroy		delete user with id 1

sample_app
===========
By default rails uses TestUnit for testing, but we will use RSpec. We must suppress the creation of the default test directory.
1. rails new sample_app -T -d mysql

2. Below is the Gemfile to be used with Rails 3.2.16
---------------------------------------------------
source 'http://rubygems.org'

gem 'rails', '3.2.16'

gem "mysql2", "0.3.11", :platforms => [:mri, :mingw]
gem "activerecord-jdbcmysql-adapter", :platforms => :jruby

group :assets do
  gem 'sass-rails',   '~> 3.2.3'
  gem 'coffee-rails', '~> 3.2.1'
  gem 'uglifier', '>= 1.0.3'
end

gem 'jquery-rails'
------------------------------------------------------------

3. Create development, production and test schemas.
create database library_development;
create database library_production;
create database library_test;
grant all privileges on library_development.* to 'yovan'@'localhost' identified by 'ab6307sn';
grant all privileges on library_production.* to 'yovan'@'localhost' identified by 'ab6307sn';
grant all privileges on library_test.* to 'yovan'@'localhost' identified by 'ab6307sn';

cd sample_app
We must install RSpec. In the Gemfile we must add the following lines:

group :test, :development do
  gem "rspec-rails", "~> 2.8"
end

bundle install
Before modifying our .gitignore file, we must generate some rspec related files:
rails generate rspec:install
Modify the .gitignore file as in the railstutorial.org/book
git init
git add.
git commit -m "Initial commit"
create a github repo for the project called sample_app
git remote add origin git@github.com:yovan-juggoo-ruby/sample_app.git
git push origin master
add yovan-juggoo as a collaborator
modify README using markdown language
git mv README README.markdown && git commit -am "Improved the README"
git push
heroku create 
git push heroku master

We want to create some static pages (home, contact, about, etc). We need a controller to manage our static pages:
We will generate the Pages controller with two actions: home and contact

rails generate controller Pages home contact 

This will modify our routes.rb  file, create the pages_controller.rb, create our views, create our pages_helper.rb and generate rspec files for the controller, views and helper class.
Open the routes.rb and we can see the two lines
get "pages/home"
get "pages/contact"
We can navigate to the home page: http:localhost:3000/pages/home and view the static content of the app/views/pages/home.html.erb view. Same goes for the contact page.

git status
git add .
git commit -m "Added a Pages controller"
We will use automated TDD - writing the test before writing the application code.
We will test for the presence of an about page
First we remove the tests for our views and helpers. We will do these tests in the controllers test.
git rm -r spec/views
git rm -r spec/helpers
ls spec -> spec_helper.rb (file used by rspec to run) and the controllers/pages_controller_spec.rb
We can run the spec directory for all of our tests(here we have one only).
rspec spec/ -> We must wait for long but we are finally green
The overhead for running our tests is because of the loading of the RSpec environment in memory. Spork can be used to speed RSpec.
Run spork in a separate terminal
rspec spec/ in another terminal -> Tests are dramatically speed up.
Now instead of running rspec spec/, we will use autotest which gives us a desktop notification on the status of our tests - growl notification.
Note: We have 4 terminals:
 - the first to issue commands
 - second for autotest
 - third for spork
 - forth for running the server
We will write a failing test for our about page - it does not exist. First of all we will open up the pages_controller_spec.rb file. All here is pure ruby. Rspec exploits Ruby to make a domain specific language (DSL).

require 'spec_helper'
describe PagesController do
	... Other tests
	describe "GET about" do
		it "should be successful" do
			get 'about' -> First we make an http get for the about ACTION get :about
			response.should be_success -> Success should be our response code for our get
		end
	end
end

On saving the file, autotests fails. 
Sometimes we have to restart Spork. Stop autotest, start spork and start autotest.
We have to
1. Create a route for the about page in routes.rb
2. Create the about action in our Pages controller
3. Create the pages/about.html.erb
4. Finally test in the browser: http://localhost:3000/pages/about

Tests are important
1. To modify code and test if it did not break previous code
2. To refactor code, i.e change functionality of some code but not its definition.

We will create dynamic pages - Dynamic title for each page.

it "should have the right title" do
	get :home
	response.should have_selector("title", :content => "Ruby on Rails Sample App | home")
end

have_selector is used to test HTML tags. The test above will fail - title in views/layouts/application.html.erb is SampleApp.
For this to work we must add the webrat gem to our Gemfile as have_selector is a webrat method:
gem 'webrat'
bundle install

1. Edit the home.html.erb file by adding the doctype, head with the title, and the already existing code.
2. Autotest will still fail. We have removed the tests on our views and are trying to test the view in our pages_controller_spec.rb file. By default this test suite will not render the views. We have to use the method render_views in our controller spec before running any view related tests.
3. Our test should pass now
4. We do the same test for the other views
5. We will modify the views html so that it is more meaningful.
6. But as we can see we have the title still showing SampleApp in the browser.
7. rm views/layouts/application.html.erb 
8. We can see that the titles are right for the pages but there is duplication of HTML code. We will add dynamic content to our views also.
9. In the actions add an instance @title="Home" and embed the title in our home view <%= title%>. Do the same for the other views. Our tests should still work.
10. We restore the default application view, change its title and remove unnecessary HTML in our views. But in our browser we will get empty pages: Blank space.
11. We will test that our HTML has a non-blank body by using regular expressions - use rubular. We want to match empty or blank body -> <body></body> or <body>   <body>
=> /<body>\s*<\/body>/ => 0 or any number of white space
 
 it "should have a non-blank body" do
 	get :home
 	response.body.should_not =~ /<body>\s*<\/body>/   -> response.body is the whole rendered HTML
end

12. We still are red. We must add embedded ruby: <%= yield%>. Now we don't have errors.
13. Add the csrf_meta_tag for cross request site forgery.
14. 
git status
git add .
git commit -am "added a site layout"
it push
git push heroku master
heroku open to view in browser

If server down we have to run the 3 commmands each in a new terminal window.
rails s
spork
autotest
We want a global title that we will specialise. A possible way to do this is by using a helper.
Note: All helpers in the helpers folder are available in any view. 

module ApplicationHelper
	# Return a title on a per-page basis.
	def title
		base_title = "Ruby on Rails Tutorial Sample App"
		if @title.nil? #By default @title being an instance variable is nil
			base_title #methods return the last line evaluated
		else
			"#{base_title} | #{@title}"
		end
	end
end

1. Change the title in application.html.erb to <%= title%> and check in browser
2. git status 
git commit -am "Added a title helper"
3. We sill use blueprint framework to create a base for our styling.
copy the blueprint folder in the zipped file in the public/stylesheets folder
4. Add the following lines to the appication.html.erb file
<%= stylesheet_link_tag 'blueprint/screen', :media => 'screen' %>
<%= stylesheet_link_tag 'blueprint/print', :media => 'print' %>

stylesheet_link_tag is a rails funtion that takes a string and a hash as arguments.
stylesheet_link_tag('blueprint/screen', { :media => 'screen' })

The above is rendered as
<link rel="stylesheet" type="text/css" media="screen" href="/stylesheets/blueprint/screen.css?1280830757"/>
The 1280830757 is there so that the page reloads the file if it changes (the number changes) - as normally browsers cache these files.

We will use the rails console to run some code.
rails c or rails console. The rails console is irb with access to rails components (controllers, helpers, database, etc).

1. "foo".concat("bar")
2. first_name = "Yovan" -> This returns the string literral "Yovan"
3. "#{first_name} #{last_name}" -> This is called interpolation
4. puts returns nil
5. print returns nil
6. "foobar".length
7. "foobar".empty?
8. "".empty? is true
9. "foobar".blank? not Ruby specific but rails specific. Useful in forms.
10. puts "Both strings are empty"  if x.empty? || y.empty?
11. if x.empty? || y.empty?
		puts "Both strings are empty"
	end
12. nil.empty? -> NoMethod error
13. nil.to_s.empty? -> true -> nil.to_s = ""
=> "#{nil}" => ""
14. false, true and nil are boolean values. "", 0 are not false but truthy values.
15. !!0, !![], !!"" returns true
16. ApplicationHelper is a module, hence gets included in the controller's class.
17. "foo bar    baz".split -> ["foo", "bar", "baz"] is an array of strings splitted on a whitespace.
"fooxxxbarxxxbax".split("xxx")
18. a = [10, 20, 30, 40]
a[-1] = 40
a.last
a.second = 20 -> rails not ruby
a.length
a.empty?
a.sort -> Returns the sorted array but a is unchanged.
a.sort! -> Returns the sorted array and changes a.
a.reverse
a.reverse!
a.shuffle
a.shuffle!
(1..52).to_a.shuffle
[1, 2] << 3 -> [1,2,3] #push operator
[1,2,"test"] << (1..5) -> [1,2,"test", 1..5]
arrays are Enumerable. Enumerable is a module in ruby where we can iterate on each element.
(1..5).each {|i| puts 2 ** 1} -> 2 4, 8, 16, 32 printed on the screen.

a = []
(1..5).each{ |i| a << 2 ** i}
a -> returns [2 4, 8, 16, 32]

It is better to use a map
a = [];
(1..5).map {|i| a << 2 ** i} -> returns [2 4, 8, 16, 32]

The same in one line: a = (1..5).map {|i| 2 ** i}
or (1..5).map do |i|
		2 ** i
	end

10.times do --> Here we don't need the i argument
	puts "Betulgeuse"
end

persons = []
10.times { |i| #i starts with 0
	persons << "person_#{i}"
}

Where we see the keyword do, we are using a block. For example in our tests and in the Gemfile.
%w[foo bar baz] -> ["foo bar baz"]
%(a b c) -> "a b c"
%(Yovan Juggoo Navaanitasingh) -> "Yovan Juggoo Navaanitasingh"
b = %w[foo bar a b c].map {|string| string.upcase} -> ["FOO", "BAR", "A", "B", "C"]
%w[a b c].map(&:upcase) -> ["A", "B", "C"]

"foo".class -> String
:foo.class -> Symbol
user = {}
user.class -> Hash
Arrays are indexed by integers but hashes can use more generic data-type.
user["first_name"] = "Yovan"
user["last_name"] = "Juggoo"
user -> {"first_name" => "Yovan", "last_name" => "Juggoo"}
user["first_name"] -> "Yovan"
user[12] = "Hello"
user -> {"first_name" => "Yovan", "last_name" => "Juggoo", 17 => "Hello"}
Hashes don't have an order on rails 3 compared to arrays which have an order
Hashes are key value pairs. The order is not important. What is important is that for every key there is a corresponding value.
employee = { "role" => "manager", "department" => "Programming", "name" => "John Doe", "salary" => 98500 }
In Rails application and in general in Ruby we use symbols as keys, not strings.
Symbols are more efficient for comparision than strings. "test" == "Test". Here comparison is done one character at a time. Symbols comparison are done on one go.

flash = { :success => "It worked!", ":error" => "It failed"}
flash.each do |key, value|
	puts "Key: #{key.inspect}  \nValue #{value.inspect}"
end

key.inspect is important cause key only will be interpolated as a string => key.to_s
puts [1, 2 ,3] prints all the elemets one by one
puts [1, 2, 3].inspect puts the array to the console
puts [1, 2, 3].inspect is same as p [1, 2, 3]

s = String.new("my_string")
a = Array.new([1, 2, 3])
h = Hash.new -> We don't initialise it. This returns {}
h[:name] = "Yovan Juggoo"
h -> {:name => "Yovan Juggoo"}
s.class.superclass -> Object
s.class.superclass.superclass -> BasicObject
s.class.superclass.superclass.superclass

class Word
	def palindrome? string
		string == string reverse
	end
end
w = Word.new
w.palindrome('foobar') -> false
w.palindrome('level') -> true

reset the console

class Word < String
	def palindrome?
		self == self.reverse
	end
end

w= Word.new('deified')
w.class -> Word
w.palindrome? -> true

We will add the palindrome? method directly on the String class

class String
	def palindrome?
		self == reverse
	end
end

"deified".palindrome?

We can load our pages controller in our console
pages = PagesController.new
pages.home -> "Home"

A ruby class - for testing purposes
class User
	attr_accessor :name, :email

	def initialize (attributes = {})
		@name = attributes[:name]
		@email = attributes[:email]
	end

	def formatted_email
		"#{@email} <#{@email}>"
	end
end

To use this code in our console, we must require it.
require './user'
user = User.new(:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com")
user.email #getter
user.email = "yovan.juggoo.ruby@gmail.com" #setter

Nested hash - hash having a hash as a key
params = {}
params[:user] = {:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com"}
params -> {:user => {:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com"}}
user = User.new(params[:user])

We will refactor our pages_controller_spec.rb file:
require 'spec_helper'
describe PagesController do
	render_views
	
	before(:each) do -> runs the same code before running each example (test bloc)
		@base_title  = "Ruby on Rails Tutorial Sample App" #@base_title should be an instance variable
	end

	describe "GET home" do
		it "should be successful" do
			get "home"
			response.should be_success
		end

		it "should have the right title" do
			get "home"
			response.should have_selector("title", :content => "#{@base_title} | Home")
		end

	end
	... Other tests
end

git status
git add .
git commit -m "Added helper and stylesheet"
git push
git push heroku
heroku open

As we will be making a large number of changes, we will create and work on a new branch of the master branch.
git checkout -b filling-in-layout

We will format our page as in mockup.png. The main page to be formatted is layouts/application.html.erb

- The HTML5 Shiv enables use of HTML5 sectioning elements in legacy Internet Explorer and provides basic HTML5 styling for Internet Explorer 6-9, Safari 4.x (and iPhone 3.x), and Firefox 3.x.
- We added also support for IE < 8 
- We added our custom stylesheet.
- blueprint expects that the content is placed in a container class.

image_tag (path, alt, class) is a rails helper method.
<%= image_tag("flower-logo.jpg", :alt => "Sample App", :class => "round")%>
is rendered to : <img alt="Sample App" class="round" src="/assets/logo.png" />

We have link_to methods for rendering our navigation.
Note here we are using '#' to stub the URL, but later we will use named routes.

The main content goes into a section tag.

We add our custom styles in custom.css to make the page more appealing.

Soon we can see that the application.html.erb file is becoming cluttered in the head of the HTML document. We will use a partial for stylesheets. In the layouts folder we will create an _stylesheets.html.erb partial.
We use the render helper method to include our partial.
<%= render 'layouts/stylesheets'> -> rails recognises partials by their name beginning with an underscore, but we use them in our layouts without the '_'.

We did same with the header and the footer. Note: for remote resources, we can either use the link_to helper method, or the classic <a href="http://path.to.resource.com">Resource</a>

For structuring purposes we stubbed our links. For example in the _footer.html.erb file, we have:
<li><%= link_to "About", "#" %></li>

We could use 
<li><%= link_to "About", "/pages/about" %></li> but this is not the rails way of doing things - use NAMED ROUTES.
The advantages:
- We can customize our /pages/about URL by using /about for example - routes.rb
- If we use the about link in several pages, we have to update the URL at one place only.
<li><%= link_to "About", about_path %></li>
But this breaks our page because there is no such path. We revert back to <li><%= link_to "About", "#" %></li>
 and will use integration testing to solve the pb.

rails g integration_test layout_links ->  create spec/requests/layout_links_spec.rb

Note in BDD we used get :home (named ROUTES), but in integration testing we use URLs ('/')
What do we want:
- The homepage to be /
- Contact page to be at /contact instead of /pages/contact
- Same for /about, /help

We use BDD to add a help page: pages_controller_spec.rb.

To match a named routes to a URL, for example match /contact with /pages/contact,
In the routes.rb file:
match '/contact', :to => 'pages#contact' -> match is a helper method. We are matching /contact and routing it to the PagesController and the contact action. This creates a named route: contact_path
Same goes for /about, /help. 
/ is particular.  root :to => 'pages#home'
Note: You can have the root of your site routed with "root". Just remember to delete public/index.html.
We can now delete the get "pages/about", etc and use the match method.
In the header partial, we will link out logo to the home page. We will use a helper logo to get the image.

Note: Suppose we have some uncommited changes. We want to append these changes to our last commit.
git add .
git commit --amend -> This will open the git editor. We can close it. The uncommited changes have been amended to the last commit.
git log -p -> The changes that were made.

A sign up creates a new user -> A UserController having a new action to create a new user.
rails g controller Users new
rm -rf spec/helpers && rm -rf spec/views -> These don't form part of git, but we dont need them either.

BDD testing for the title for the new action: "Sign up".
We would like to be redirected at the /users/new page with /signup
As previously, we use integration testing to map and test our signup_path.

Note: Integration testing is mostly used to after the work has been done - to double check.
For example we can test our links.

git status
git add .
git commit -am "Added UsersController and layout link tests"
git checkout master
git merge filling-in-layout
git push origin master

ActiveRecord is the default Rails library to deal with DB. 
We will use migrations - interface to SQL DDL.
In scaffolding the controller, model and views are generated for us. But as we generated manually our controller, we will generate the data model.

git checkout -b modeling-users -> Create a new branch
rails g model User name email -> Controllers are plurial and models are singular

20160816132549_create_users.rb -> Generated class for us which inherits from Migration. We already have columns defined.
create_table :users do |t| -> t is the data model
We can see that rails defines our fields as columns and t.timestamps represent the created_at and updated_at columns. The id column is automatically created for us. We can see the same in schema.rb.

rake db:migrate -> Creates our tables in the database
rake db:rollback -> Deletes the table

rake db:migrate

Add gem 'annotate' to group development so that we can annotate our models.
bundle install
annotate -> Annotated user: Annotated (2): app/models/user.rb, spec/models/user_spec.rb
Useful so that we can clearly see the columns and datatypes.

We should restrict the fields that are accessible via the web interface. For example id is not a public attribute.
Use attr_accessible :name. :email -> Already done for us.

git add .
git commit -m "Created a User model"

rails c --sandbox -> Nothing is persisted in the DB. Any modifications are rollded back on exit.
tail -f log/development.log -> To read the logs
User.new -> This creates a user object with nil attributes. This object is not yet persisted in the DB.
user = User.new(:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com") -> To create a new user we pass in a hash. The id, created_at and updated_at fields are nil at this moment.
Nothing happens in the development log. We must save the user object to  persist the data. 
user.save -> Returns true. Useful for boolean tests. This generate the SQL INSERT command. create_at and updated_at now have the proper timestamps - UTC.
user.name
user.created_at
Note: We don't define our fields in the user.rb model file. Active record looks at the database and infers which are our fields.
user2 = User.create(:name => "John Doe", :email => "john.doe@example.com") -> The user object is instanciated, the id, created_at and updated_at are automatically set and the user object is returned. The user object is automatically created. -> Create command.
user2.destroy -> Destroys the user. The user object is returned by the method. DELETE command.
User.find(1) -> returns a user by id.
User.find(100) -> Raises an exception: Record not found. Useful when we want to raise an exception if the user does not exist.
User.find_by_id(100) -> returns the user object if found or nil. This does not raise an exception. Useful if we don't want to handle any exception.
User.find_by_email("yovan.juggoo@gmail.com") -> Useful as most of the time we use the user's email as login.
User.first
User.last
User.all
user.email = "yovan.juggoo@example.net"
user.save -> returns a boolean. The user is persisted only at this point.
user.email = "unknown@nowhere.com"
user.reload -> Our user's email is as it was previously.
user.update_attributes(:name => "The dude", :email => "dude@abides.org") -> To update several attributes at the same time. Returns a boolean value. Only accessible attributes are updateable.

Validations in the user model
	validates :name, :presence => true
To reload the user model in the console, we have to use the reload! method
user = User.new(:email => "foo@example.com")
user.save -> returns false  
Note: When we create models with validations, rails creates an array of error messages.
user.errors.full_messages -> Returns ["Name can't be blank"]
user.valid? -> Returns false
user2 = User.create(:email => "foo@example.com") -> Does not raise an error but the id is null
user2 = User.create!(:email => "foo@example.com") -> The ! is used to raise an error if the object is not valid

We have already written the validation code. To use TDD, we comment out the code, write our failing tests and make the tests pass, i.e uncomment the validation code.

We can run the test file for our user model that rails created for us: spec/models/user_spec.rb
As there are real tests defined in this file, we get a 1 pending test warning: rspec spec/models/user_spec.rb

We write our tests as follows: 

it "should create a new instance given a valid attribute" do
	User.create!(:name: "Example User", :email => "user@example.edu")
end

But we get the following error for our test:
1) User should create a new instance given a valid attribute
     Failure/Error: User.create!(:name => "Example User", :email => "user@example.edu")
     ActiveRecord::StatementInvalid:
       Mysql2::Error: Table 'sample_app_test.users' doesn't exist: SHOW FULL FIELDS FROM `users`
     # ./spec/models/user_spec.rb:17:in `block (2 levels) in <top (required)>'

This error occurs because we did not prepare our test database.
rake db:test:prepare
rspec spec/models/user_spec.rb -> The test passes

We uncomment the name validation and write a test for a non valid user, i.e a user who's name was not provided.
it "should require a name" do
	no_name_user = User.new(:email => "jane.smith@test.com")
	no_name_user.should_not be_valid # when we have a be_test, this means that rspec will run the test? method on the the object
end

Same is done for the email validation.
We have duplication of test data in our tests. We can use an instance variable in a before(:each) bloc so that test data is available in each tests. For this we will use the Hash.merge method.
When testing for a valid user, we are using a user object who's :name attribute is nil. But when using forms, we can have empty strings.

hash = { :name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com" }
hash.merge(:name => "") -> returns the unmutated hash { :name => "", :email => "yovan.juggoo@gmail.com" }
hash.merge!(:name => "") -> returns the mutated hash { :name => "", :email => "yovan.juggoo@gmail.com" }, i.e the hash is modified.

We will write a failing test for the :name attribute, which should be at most 50 characters long.
s = "a" * 51 returns "a....a", 51 characters

 it "should reject names that are too long" do
  	long_name = "a" * 51
  	long_name_user = User.new(@user.merge(:name => long_name))
  	long_name_user.should_not be_valid
  end

validates :name, :presence =>  true, :length => { :maximum => 50 }

We will test for valid email addresses.
addresses = %w[user@foo.com THE_USER@foo.bar.org first.last@foo.jp]
Use Rubular for the email RegEx. Maybe there already have Ruby methods or gems for testing emails.

email_regex = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
validates :email, :presence =>  true, :format => { :with => email_regex }

Now we will try to test for the uniqueness of email addresses in the DB. Uniqueness should also be case insensitive.

it "should reject duplicate email addresses" do
    User.create!(@user)
    user_with_duplicate_email = User.new(@user)
    user_with_duplicate_email.should_not be_valid
  end

   it "should reject email addresses identical up to case" do
   	upcased_email = @user[:email].upcase
   	User.create!(@user.merge(:email => upcased_email))
	user_with_duplicate_email = User.new(@user)
    user_with_duplicate_email.should_not be_valid
  end
validates :email, :presence =>  true, :format => { :with => email_regex }, 
  					:uniqueness => { :case_sensitive => false }

Now we will add an index to our email column for quick search. We need a migration.
Create migrations are implicit - when we do a rails g model Model fields. 
rails g migration add_email_uniqueness_index
We edit the migration file as follows:

class AddEmailUniquenessIndex < ActiveRecord::Migration
  def up
  	add_index :users, :email, :unique => true
  end

  def down
  	remove_index :users, :email
  end
end

Note: We added an index on the email column of the users table and stated that this index should be unique. add_index is a method.
In the down migration we use the remove_index method to delete the index.
rake db:migrate

As a good habit we do a rake db:test:prepare and run our tests.

git add .
git commit -m "User model validations"

In application.html.erb, we put some debugging -> <%= debug params if Rails.env.development? %>

rails c -> Not in sandbox, so persistent.
User.create!(:name => "Yovan Juggoo", :email => "yovan.juggoo@gmail.com")

1. Create a layout to show user info.  -> views/layouts/users/show.html.erb

Http request	URL				Action 		Purpose
========================================================================
GET 			/users/1 		show		page to show user with id 1

In this page we display only the user's name and email. We have to define an instance variable @user in the UsersController.
<%= @user.name  %>, <%= @user.email %>


2. Add the mapping to our users#show action in the routes.rb file.
We add resources :users (this does all the routing mapping for all actions) and delete the line get "users/new" as this is implicit when we use  resources :users .

3.  We can an error "undefined method name for nil:NilClass" if we run localhost:7777/users/1.
This is because @user is not defined in the controller ans hence is nil.

4. We define the show action and return @user
	def show
		#@user = User.find(1) -> We don't want to hardcode the id.
		@user = User.find(params[:id])
	end

git add .
git commit -m "added a stub user show page"

First of all we use insecure passwords to get things working and  then we'll use secure passwords.
We won't use a migration to create a password column as we would finally want to use encrypted passwords.
We will create a password that requires confirmation.
We will use the respond_to? method to check for the presence of a password attribute on a user object.
Always use the respond_to? method to test when a new attribute is added in our models.

We will style our users show page as profile_mockup_profile_name.png
We will style our Sign up page as signup_mockup.png


rails c
user = User.new
user.respond_to?(:name) -> This is the same as asking if the user has an attribute name
user.respond_to?(:yovan) -> Returns false. 

We use a test to test whether our User model resonds to the :password attribute in the user_spec.rb.
describe "passwords" do
    it "should have a password attribute" do
      User.new(@sample_user).should respond_to(:password)
    end
end

rspec spec\models\user_spec.rb
This will fail as we don't have a password field in our user model.
We will use a normal Ruby attribute to hold our password, because in the end we will be using encrypted passwords: 
attr_accessor :password -> This will create the getters and setters to manipulate passwords. It will be a virtual attribute.
Now the test should pass.
We will test for respond_to :password_confirmation also. But we will not add the password_confirmation attribute as we did with the password attribute.
- First of all we will add password validations test in our user_spec.rb.
- We are still red so we add a vaidation for our :password attribute.

validates :password, :presence => true, :confirmation => true
- The password is now required
- implicitly a required password_confirmation attribute is created for us.
- If we run our tests once again we'll see that some of our older tests fail. This is because the :password attribute is now required.
We should update our @user_hash value in our before:each block.
We re-run our tests and get the following errors:
Failure/Error: User.create! @user_hash
 ActiveModel::MassAssignmentSecurity::Error:
   Can't mass-assign protected attributes: password, password_confirmation

This happens because the :password and :password_confirmation attributes have to be made accessible.

Note: All fields that will be accessible through the web must be attr_accessible.
We are green now if we run our tests.
For our password mismatch test, "invalid" does not match our password in @user_hash

We write a failing test for short and long passwords and then the corresponding validations - passwords should be at least 6 characters long and have a maximum length of 40.
validates :password, :presence => true, :confirmation => true, :length => { :minimum => 6, :maximum => 40 }
The better way to write the validation above:
validates :password, :presence => true, :confirmation => true, :length => { :within => 6..40 }

We are not storing the value of the :password attribute in the database. The encrypted password is saved in an encrypted_password colums - we have to create a migration.
First we write a failing test for the presence of the encrypted password attribute. We must create a user in the database (in the before:each block).

Previously we generated a migration to add an index to the email attribute of the user table. It was a convenience migration. Here we will generate a special migration.

rails g migration add_password_to_users encrypted_password:string

If we open the migration file we can see that rails has automatically written the add_column and remove_column method calls in the up and down methods respectively.
Note: In Rails 3.2.16 we don't have the self.up and self.down methods. Instead the add_column method is called in the change method.

def change
 add_column :users, :encrypted_password, :string
end

Now we run the migration to create the encrypted_password column in the database and we annotate the user model.
rake db:migrate
annotate

If we run the tests again after creation of the encrypted_password column, we will still be red, despite the fact that the encrypted_password attribute is implicitly accessible. This is because we migrated our development DB but have not prepared our test database to reflect these changes.

rake db:test:prepare

If we want to run only one particular example
rspec path_to_test_file -e "test_description", for example
rspec spec\models\user_spec.rb -e "should have an encrypted password attribute"

We then write a failing test for the encrypted password should not be blank.
For testing purposes we run the rails console in a sandbox:
rails c -s
user = User.create! :name => "Example User", :email => "example@example.net", :password => "password", "password_confirmation" => "password"
As we can see we do create the user object, but the encrypted password is nil. What we want is before the user is saved, we set the value of the encrypted_password to a hashed encrypted value of the password attribute.

We will register a callback for the encrypted_password.
register means write the code 
callback methods are methods that are ran at a particular time in the life-cycle of an object.

1. We define the callback method encrypt_password in the user model, which will run before the user object is saved.
before_save :encrypt_password
2. As the encrypt_password method should only be available in the User class, we must make this method private.
If we try to run the private method in the rails sandbox console, we get a NoMethodError: private method 'encrypt_password' called
3. Write a dummy code for our private encrypt_password method. We want the encrypt_password method to set the value of our :encrypted_password attribute to an encrypted version of our :password attribute.
In the context of the class itsef we use self.encrypted_password = value to set the encrypted_password attribute.

Note: If we don't use self.encrypted_password in the method, Ruby will create a local encrypted_password variable.

We will use another private method encrypt to perform the actual encryption. As we have not written the implementation of the encrypt method, we will return the string itself passed as a parameter to the method.

def encrypt(value)
	value
end

If we run our test again it should be green now.

Normally a user signs in via a form and we have to compare the submitted password with the encrypted password in the database. We cannot compare the passwords directly; we should encrypt the submitted password and then compare it to the encrypted_password in the database.
We should define a has_password boolean method in the User class, which will return true if the user object has the encrypted_password.
First we write a failing test for the has_password method.
After adding the has_password?(submitted_password) method, we should be green.

Secondly, we should test if the submitted_password and encrypted_password match. This is done by using the has_password?(submitted_password) method which will return a boolean value whether the encrypted_password == encrypt(submitted_password)

rails c -s
require 'digest'
Digest::SHA2.hexdigest("foobar")

def secure_hash(string)
	Digest::SHA2.hexdigest(string)
end

password = "secret"
encrypted_password = secure_hash(password)

submitted_password = "secret"
encrypted_password = secure_hash(secret)

If we know the hashing algorithm of the password, by rainbow attack, we can guess the password of a user by comparing the hashed password with the encrypted password.
We should use a unique salt for each user. The salt we use here is the combination of the current time and the user's password. This ensures that two users having the same password will have a different encrypted_password as long as they both don't create their accounts at the same time.

Time.now
Time.now.utc

salt = secure_hash("#{Time.now.utc}---#{submitted_password}")
encrypted_password = secure_hash("#{salt}--#{submitted_password}")

We have to store the salt, hence we need to add an attribute to the user model.
First we write a failing test for the salt attribute in the password encryption describe block.
We need to add a migration for the salt column.
rails g migration add_salt_to_users salt:string
rake db:migrate && rake db:test:prepare
rspec spec\models\user_spec.rb


We will define the encrption machinery in the user model by defining a secure_hash(string) method.

Note: In the encrypt(string) method we don't pass the salt because salt is an attribute of the user model.

Important:
1. We set the salt in the encrypt_password method by calling the make_salt method.
2. We don't need to create a new salt in the encrypt_password method each time we have to encrypt a submitted password. A new salt is created only if the user object is a new record. The new_record? method of ActiveRecord tests whether a model object is a new record.

We should be green.

rails c -s
user = User.create!(:name => "Pierre Anne", :email => "pierre.anne@gmail.com", :password => "foobar", :password_confirmation => "foobar")

As we can see the user.salt and user.encrypted_password have been set. The salt will not change, but the encrypted_password will change if the user changes his password.

user.has_password?("foobar") returns true

In the application, we will authenticate the user by their email and compare their submitted password with the encrypted_password =>
1. not_logged_in_user = User.find_by_email("pierre.anne@gmail.com")
2. submitted_password = "foobar"
3. not_logged_in_user.has_password?(submitted_password)

We need a method to authenticate a user based on his email and his submitted_password: User.authenticate(email, submitted_password)

We write failing tests to test whether a user is authenticated.
1. Test for the authenticate method. authenticate is a CLASS method.
2. Test if email/password mismatch.
3. Test if a valid email/password returns the correct user.

In the authenicate method, we find the user by email. If the user is nil, we return nil.
If the user is not nil, i.e there is a user for the given email, we return the user if he has the given password.
Else as the user does not have the password, we will return nil automatically.

In the console (rails c -s)
User.authenticate("pierre.anne@gmail.com", "foobar") returns the user object.

In routes.rb, we defined our users routes using resources :users
We get the new and show (and other actions) matched for free in the file. 
Also we have matched our /signup URL to the new action.

We write a test to get the show page in our users_controller.rb test file: 
render_views

describe "GET 'show'" do
	 it "returns http success" do
	  get :show
	  response.should be_success
	end
end

rspec spec\controllers\user_controller_spec.rb
But we get the following error:
No route matches {:controller=>"users", :action=>"show"}
We must pass an id to the show page => /user/id

So we must use pass an id to our show method:
get :show, :id => some_id

We don't have any users in our test database. We'll use factories to add users to the test database.
We could use User.create! to define our users, but factories are more convenient.
We will use FactoryGirl. 
In the Gemfile: add gem 'factory_girl_rails', '1.0' inside our test group.
bundle install
To automatically load our data inside our tests we use a file called factories.rb inside our spec directory.
In the line Factory.define :user do |user|, factory girl knows, by looking at the symbol :user, that we want to use the User class.

In the users_controller_spec.rb, first of all we create a user in the before:each block using FactoryGirl.
@user = Factory(:user). In this line, we could have passed a hash to the Factory constructor. It uses the default values defined in fatories.rb.

Then we test for response if successful for :show action: 
get :show, :id => @user.id #we could also use get :show, :id => @user as rails knows that it must pass the id of the @user object.
response.should be_success

We want to test whether the user we pull out of the DB using the :show action is the real user.
1. We comment the line #@user = User.find(params[:id]) in the show action method, so that our test fails at first.
2. Then we write the test "should find the right user"
a. First of all we get the user by passing it the user previously defined by FactoryGirl.
b. We use the assign method to test wheter the user passed to the show method is the user we get as output. assigns(:user) is @user in the UsersController.
The test should fail at first because we commented the line.
By uncommenting the commented line, we are green.

Test if the show page has the user's name as a title. To make the test pass @title = @user.name in users_controller.
Note: Showing the user name in the browser is potentially dangerous. Suppose the user adds Javascript in this name, we would open our site to cross-scripting attacks. In Rails 3 HTML is escaped ny default.
If we really want to show the script we should use the raw method
<h1><%= raw(@user.name + "<script>" %></h1>


We will test for the presence of a gravatar image in the show page.
gem "gravatar_image_tag", "0.1.0"
bundle install
In our users/show.html.erb file we have:
<h1>
<%= gravatar_image_tag @user.email%>
<%= "#{@user.name}" %>
</h1>

We will test whether we have an image having a class="gravatar". This eventually fails as we have not defined our gravatar class.
To make the test to pass, we can pass a class="gravatar" to our gravatar_image_tag method: 
gravatar_image_tag @user.email, :class => 'gravatar'

But, it is better to define a helper method where these default values and options can be set:
module UsersHelper
	def gravatar_for(user, options = {:size => 50})
		gravatar_image_tag(user.email.downcase, :alt => user.name, :class => "gravatar", :gravatar => options)
	end
end

We have used an options hash to set some default values for our gravatar. We could look up the API for more. Gravatars are squares so a size value suffices.
We use our method in our helper: <%= gravatar_for @user%>. Note we did not pass the size parameter; it was set by default for us.

Note: To update a record using the console:
rails c
User.first.update_attributes(:email => "yovan.juggoo@gmail.com", :password => "foobar", :password_confirmation => "foobar")

















